<howto>
h1.  Locking Example

h2.  Summary

Terracotta ensures correctness of clustered data using the same semantics that Java uses to guarantee correctness of main memory - the {{synchronized}} keyword.  The synchronized keyword marks the start and end of a transaction boundary.  _(Note that Java 1.5 ReentrantReadWriteLock is also supported, in the way you would expect - lock and unlock operations mark the beginning and end of transaction boundaries.)_

When a lock is acquired, Terracotta ensures that all transactions that have been submitted under that lock are applied, so the memory in the node acquiring the lock is up to date and consistent.

If a lock is released, and writes were made, then Terracotta uses that lock release as the boundary to submit a transaction.  Changing your lock boundaries changes the granularity of Terracotta transactions, just like in regular Java!  Locking that is too fine may be easy to understand, but may have performance overhead.  Making locks more course-grained may thus help performance.

As with any performance tuning, always start with correctness, measure and test, and if you find any part of your application to be slow, and have measured lock overhead that is too fine, then begin to adjust your lock overhead.

This example shows you, besides lock-granularity, the available lock settings that you can use to adjust read, write, concurrent and auto-synchronize features to get the best mix of locking behavior that matches your application.

h2.  How to run

*Node 1:*
{code}
$ javac *.java
$ start-tc-server &amp;
$ dso-java Main
Successfully put key1: key1
Successfully put key2: key2
Successfully put key3: key3
Successfully put key4: key4
Successfully put key5: key5
Key1 is: key1
Key2 is: key2
Key3 is: key3
Key4 is: key4
{code}
</howto>
