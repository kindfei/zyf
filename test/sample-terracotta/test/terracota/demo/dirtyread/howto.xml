<howto>
h1. Fault Tolerant With Dirty Reads Example

h2.  Summary

{warning}
*NOTE: DO NOT USE THIS PATTERN IF YOU ARE A NEW OR BEGINNING TERRACOTTA USER*

This pattern is here to demonstrate that it is possible to make certain tradeoffs with Terracotta, e.g. data availability for data coherence.  If you are just starting to use Terracotta, you *should not do this* - start with data correctness and coherence first, and only when you are an expert user, and have very specific requirements, should you consider using this strategy.

*Note that a typical Terracotta installation will have extremely high availability anyway*, with no single points of failure.  This is sufficient for the majority of use cases.  Planning for a 100% server layer failure is not a recommended excercise.  Instead, plan on how to eliminate this case - *Terracotta includes all of the necessary features to provide a fully redundant server layer*, which is resilient to single points of failure, and thus it is not necessary to employ the technique discussed in this page.
{warning}

This example builds on the helloworld example to show the use of a dirty read.  By using a dirty read, we can ensure that the readers are not interfered with by other events in the cluster - e.g. writes to the clustered data, and in fact even a 100% failure of the Terracotta server layer.

The sample has two parts - a writer and a reader.  The writer runs be default, the reader runs if args are passed to the main method.  The reader runs in a while loop, printing the value of the counter every 200ms.  Since it is not read-locked, it's data is dirty - e.g. it may not be coherent, but it is 100% available, it does not matter if the writer blocks for a long time while updating, or even if the Terracotta server layer fails 100%, the reader thread will continue to run.

h2.  How to run

First, let's start the server...

*Node 1:*
{code}
$ javac *.java
$ start-tc-server &amp;
{code}

Now let's start the reader...

*Node 2:*
{code}
$ dso-java Main read
[Fri Jul 04 12:25:00 PDT 2008] Counter is: 0
[Fri Jul 04 12:25:00 PDT 2008] Counter is: 0
[Fri Jul 04 12:25:01 PDT 2008] Counter is: 0
...
{code}

Now let's run a writer node to increment the count...

*Node 3:*
{code}
$ dso-java Main
Counter is: 1
{code}

Notice that the reader gets the update:
*Node 2:*
{code}
[Fri Jul 04 12:25:12 PDT 2008] Counter is: 0
[Fri Jul 04 12:25:12 PDT 2008] Counter is: 1
...
{code}

Now let's kill the server...press &lt;ctrl-c&gt; in the server window (Node 1)

Notice that the reader thread is still going:

*Node 2:*
{code}
[Fri Jul 04 12:25:18 PDT 2008] Counter is: 1
[Fri Jul 04 12:25:18 PDT 2008] Counter is: 1
[Fri Jul 04 12:25:19 PDT 2008] Counter is: 1
[Fri Jul 04 12:25:19 PDT 2008] Counter is: 1
[Fri Jul 04 12:25:19 PDT 2008] Counter is: 1
{code}

Next, start another writer, which will have to wait for the server to come back...

*Node 3:*
{code}
$ dso-java Main
2008-07-04 12:25:25,016 ERROR - We couldn't load l1 reconnect properties from any of the servers. Retrying.....
2008-07-04 12:25:26,019 WARN - We couldn't load l1 reconnect properties from the URL :
http://192.168.110.103:9510/l1reconnectproperties 
 Skipping this source and going to the next one.
...
{code}

Finally, start the server again:

*Node 1:*
{code}
$ javac *.java
$ start-tc-server &amp;
{code}

Notice that the writer thread connects and increments the counter:
*Node 1:*
{code}
Counter is: 2
{code}

And the reader thread reflects the change:
*Node 2:*
{code}
[Fri Jul 04 12:25:31 PDT 2008] Counter is: 1
[Fri Jul 04 12:25:31 PDT 2008] Counter is: 2
[Fri Jul 04 12:25:32 PDT 2008] Counter is: 2
[Fri Jul 04 12:25:33 PDT 2008] Counter is: 2
{code}

</howto>
